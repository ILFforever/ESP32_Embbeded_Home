#include "backend_stream.hpp"
#include "esp_log.h"
#include "esp_http_client.h"
#include "esp_wifi.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include <cstring>
#include <cstdlib>

namespace backend_stream {

static const char *TAG = "BackendStream";

// Queue handles
static QueueHandle_t camera_queue = nullptr;
static QueueHandle_t audio_queue = nullptr;

// Task handles
static TaskHandle_t camera_task_handle = nullptr;
static TaskHandle_t audio_task_handle = nullptr;

// Streaming state
static bool camera_streaming_active = false;
static bool audio_streaming_active = false;

// Statistics
static StreamStats stats = {0};

// Frame rate limiting for camera
static uint32_t last_frame_sent_time = 0;
static const uint32_t FRAME_INTERVAL_MS = 200;  // 5 FPS

// Persistent HTTP clients for streaming (keep-alive)
static esp_http_client_handle_t persistent_camera_client = nullptr;
static esp_http_client_handle_t persistent_audio_client = nullptr;

// ============================================================================
// Internal: Get or create persistent HTTP client for camera
// ============================================================================
static esp_http_client_handle_t get_camera_http_client() {
    if (persistent_camera_client != nullptr) {
        // Client already exists, reuse it
        return persistent_camera_client;
    }

    // Create new persistent client
    char url[256];
    snprintf(url, sizeof(url), "http://%s:%d/api/v1/devices/%s/stream/camera",
             BACKEND_SERVER_HOST, BACKEND_SERVER_PORT, DEVICE_ID);

    esp_http_client_config_t config = {};
    config.url = url;
    config.method = HTTP_METHOD_POST;
    config.timeout_ms = 5000;
    config.keep_alive_enable = true;
    config.keep_alive_idle = 5;
    config.keep_alive_interval = 5;
    config.keep_alive_count = 3;

    persistent_camera_client = esp_http_client_init(&config);
    ESP_LOGI(TAG, "Created persistent HTTP client for camera streaming");

    return persistent_camera_client;
}

// ============================================================================
// Internal: Get or create persistent HTTP client for audio
// ============================================================================
static esp_http_client_handle_t get_audio_http_client() {
    if (persistent_audio_client != nullptr) {
        // Client already exists, reuse it
        return persistent_audio_client;
    }

    // Create new persistent client
    char url[256];
    snprintf(url, sizeof(url), "http://%s:%d/api/v1/devices/%s/stream/audio",
             BACKEND_SERVER_HOST, BACKEND_SERVER_PORT, DEVICE_ID);

    esp_http_client_config_t config = {};
    config.url = url;
    config.method = HTTP_METHOD_POST;
    config.timeout_ms = 3000;
    config.keep_alive_enable = true;
    config.keep_alive_idle = 5;
    config.keep_alive_interval = 5;
    config.keep_alive_count = 3;

    persistent_audio_client = esp_http_client_init(&config);
    ESP_LOGI(TAG, "Created persistent HTTP client for audio streaming");

    return persistent_audio_client;
}

// ============================================================================
// Internal: Check WiFi connectivity
// ============================================================================
static bool check_wifi_connected() {
    wifi_ap_record_t ap_info;
    esp_err_t ret = esp_wifi_sta_get_ap_info(&ap_info);

    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "WiFi connected to: %s, RSSI: %d", ap_info.ssid, ap_info.rssi);
        return true;
    } else {
        ESP_LOGE(TAG, "WiFi NOT connected! Error: %s", esp_err_to_name(ret));
        return false;
    }
}

// ============================================================================
// Internal: Send camera frame to backend
// ============================================================================
static esp_err_t send_camera_frame_blocking(CameraFrame* frame) {
    uint32_t start_time = xTaskGetTickCount() * portTICK_PERIOD_MS;

    // Build URL
    char url[256];
    snprintf(url, sizeof(url), "http://%s:%d/api/v1/devices/%s/stream/camera",
             BACKEND_SERVER_HOST, BACKEND_SERVER_PORT, DEVICE_ID);

    // Create new HTTP client for each request (simpler and faster than persistent)
    esp_http_client_config_t config = {};
    config.url = url;
    config.method = HTTP_METHOD_POST;
    config.timeout_ms = 3000;

    esp_http_client_handle_t client = esp_http_client_init(&config);
    if (client == nullptr) {
        ESP_LOGE(TAG, "Failed to init HTTP client");
        stats.camera_frames_failed++;
        return ESP_FAIL;
    }

    // Create boundary
    char boundary[64];
    snprintf(boundary, sizeof(boundary), "----ESP32Frame%lu", (unsigned long)frame->timestamp);

    // Build form data in buffer
    size_t buffer_size = 1024 + frame->size;
    char* post_data = (char*)malloc(buffer_size);
    if (post_data == nullptr) {
        ESP_LOGE(TAG, "Failed to allocate buffer");
        esp_http_client_cleanup(client);
        stats.camera_frames_failed++;
        return ESP_FAIL;
    }

    int offset = snprintf(post_data, buffer_size,
        "--%s\r\n"
        "Content-Disposition: form-data; name=\"device_id\"\r\n\r\n%s\r\n"
        "--%s\r\n"
        "Content-Disposition: form-data; name=\"frame_id\"\r\n\r\n%u\r\n"
        "--%s\r\n"
        "Content-Disposition: form-data; name=\"timestamp\"\r\n\r\n%lu\r\n"
        "--%s\r\n"
        "Content-Disposition: form-data; name=\"frame\"; filename=\"frame.jpg\"\r\n"
        "Content-Type: image/jpeg\r\n\r\n",
        boundary, DEVICE_ID, boundary, frame->frame_id,
        boundary, (unsigned long)frame->timestamp, boundary);

    memcpy(post_data + offset, frame->data, frame->size);
    offset += frame->size;
    offset += snprintf(post_data + offset, buffer_size - offset, "\r\n--%s--\r\n", boundary);

    // Set headers
    char content_type[128];
    snprintf(content_type, sizeof(content_type), "multipart/form-data; boundary=%s", boundary);
    esp_http_client_set_header(client, "Content-Type", content_type);

    char auth_header[256];
    snprintf(auth_header, sizeof(auth_header), "Bearer %s", API_TOKEN);
    esp_http_client_set_header(client, "Authorization", auth_header);

    // Set POST data and perform
    esp_http_client_set_post_field(client, post_data, offset);
    esp_err_t err = esp_http_client_perform(client);

    free(post_data);

    if (err != ESP_OK) {
        ESP_LOGE(TAG, "HTTP request failed: %s", esp_err_to_name(err));
        esp_http_client_cleanup(client);
        stats.camera_frames_failed++;
        return err;
    }

    int status_code = esp_http_client_get_status_code(client);
    esp_http_client_cleanup(client);  // Always cleanup after each request

    uint32_t total_duration = (xTaskGetTickCount() * portTICK_PERIOD_MS) - start_time;
    stats.last_send_duration_ms = total_duration;

    if (stats.camera_frames_sent % 10 == 0) {
        ESP_LOGI(TAG, "Frame %u: status=%d, time=%lums", frame->frame_id, status_code, total_duration);
    }

    if (status_code == 200 || status_code == 201) {
        stats.camera_frames_sent++;
        return ESP_OK;
    } else {
        ESP_LOGE(TAG, "Backend returned status %d", status_code);
        stats.camera_frames_failed++;
        return ESP_FAIL;
    }
}

// ============================================================================
// Internal: Send audio chunk to backend
// ============================================================================
static esp_err_t send_audio_chunk_blocking(AudioChunk* chunk) {
    // Get persistent HTTP client (reuses TCP connection)
    esp_http_client_handle_t client = get_audio_http_client();
    if (client == nullptr) {
        ESP_LOGE(TAG, "Failed to get HTTP client for audio");
        stats.audio_chunks_failed++;
        return ESP_FAIL;
    }

    // Set headers for THIS request
    esp_http_client_set_header(client, "Content-Type", "application/octet-stream");

    char auth_header[256];
    snprintf(auth_header, sizeof(auth_header), "Bearer %s", API_TOKEN);
    esp_http_client_set_header(client, "Authorization", auth_header);

    char sequence_header[32];
    snprintf(sequence_header, sizeof(sequence_header), "%lu", (unsigned long)chunk->sequence);
    esp_http_client_set_header(client, "X-Sequence", sequence_header);

    // Set POST field (this sets the body)
    esp_http_client_set_post_field(client, (const char*)chunk->data, chunk->size);

    // Perform the request (reuses connection if server allows)
    esp_err_t err = esp_http_client_perform(client);

    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Audio HTTP perform failed: %s", esp_err_to_name(err));
        // Cleanup and reset on connection error
        esp_http_client_cleanup(client);
        persistent_audio_client = nullptr;
        stats.audio_chunks_failed++;
        return err;
    }

    int status_code = esp_http_client_get_status_code(client);

    if (status_code == 200 || status_code == 201) {
        stats.audio_chunks_sent++;

        // Log periodically
        if (stats.audio_chunks_sent % 50 == 0) {
            ESP_LOGI(TAG, "Audio chunk %lu sent (%zu bytes, total: %lu KB)",
                     (unsigned long)chunk->sequence, chunk->size,
                     (unsigned long)(stats.audio_chunks_sent * chunk->size) / 1024);
        }

        // DON'T cleanup - connection will be reused!
        return ESP_OK;
    } else {
        ESP_LOGE(TAG, "Audio backend returned status %d", status_code);
        // On error, cleanup and recreate
        esp_http_client_cleanup(client);
        persistent_audio_client = nullptr;
        stats.audio_chunks_failed++;
        return ESP_FAIL;
    }
}

// ============================================================================
// FreeRTOS Tasks
// ============================================================================
static void camera_stream_task(void* param) {
    ESP_LOGI(TAG, "Camera streaming task started");

    CameraFrame frame;

    while (true) {
        // Wait for frames in queue
        if (xQueueReceive(camera_queue, &frame, portMAX_DELAY) == pdTRUE) {
            // Only send if streaming is active
            if (camera_streaming_active) {
                send_camera_frame_blocking(&frame);
            }

            // Free frame buffer
            if (frame.data != nullptr) {
                free(frame.data);
            }

            // Delay between frames
            vTaskDelay(pdMS_TO_TICKS(50));
        }
    }
}

static void audio_stream_task(void* param) {
    ESP_LOGI(TAG, "Audio streaming task started");

    AudioChunk chunk;

    while (true) {
        // Wait for audio chunks in queue
        if (xQueueReceive(audio_queue, &chunk, portMAX_DELAY) == pdTRUE) {
            // Only send if streaming is active
            if (audio_streaming_active) {
                send_audio_chunk_blocking(&chunk);
            }

            // Free chunk buffer
            if (chunk.data != nullptr) {
                free(chunk.data);
            }

            // Minimal delay
            vTaskDelay(pdMS_TO_TICKS(10));
        }
    }
}

// ============================================================================
// Public API
// ============================================================================

esp_err_t init() {
    if (camera_queue != nullptr) {
        ESP_LOGW(TAG, "Already initialized");
        return ESP_OK;
    }

    // Create queues
    camera_queue = xQueueCreate(3, sizeof(CameraFrame));
    audio_queue = xQueueCreate(10, sizeof(AudioChunk));

    if (camera_queue == nullptr || audio_queue == nullptr) {
        ESP_LOGE(TAG, "Failed to create queues");
        return ESP_FAIL;
    }

    // Create camera streaming task on Core 0
    BaseType_t ret = xTaskCreatePinnedToCore(
        camera_stream_task,
        "camera_stream",
        8192,  // 8KB stack
        nullptr,
        3,  // Priority 3
        &camera_task_handle,
        0   // Core 0
    );

    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create camera stream task");
        return ESP_FAIL;
    }

    // Create audio streaming task on Core 0
    ret = xTaskCreatePinnedToCore(
        audio_stream_task,
        "audio_stream",
        6144,  // 6KB stack
        nullptr,
        3,  // Priority 3
        &audio_task_handle,
        0   // Core 0
    );

    if (ret != pdPASS) {
        ESP_LOGE(TAG, "Failed to create audio stream task");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Backend streaming initialized (target: %s:%d)",
             BACKEND_SERVER_HOST, BACKEND_SERVER_PORT);

    return ESP_OK;
}

void start_camera_streaming() {
    camera_streaming_active = true;
    last_frame_sent_time = 0;
    ESP_LOGI(TAG, "Camera streaming started");
}

void stop_camera_streaming() {
    camera_streaming_active = false;
    ESP_LOGI(TAG, "Camera streaming stopped");
}

bool is_camera_streaming() {
    return camera_streaming_active;
}

void start_audio_streaming() {
    audio_streaming_active = true;
    ESP_LOGI(TAG, "Audio streaming started");
}

void stop_audio_streaming() {
    audio_streaming_active = false;
    ESP_LOGI(TAG, "Audio streaming stopped");
}

bool is_audio_streaming() {
    return audio_streaming_active;
}

esp_err_t queue_camera_frame(const uint8_t* jpeg_data, size_t jpeg_size, uint16_t frame_id) {
    if (camera_queue == nullptr || !camera_streaming_active) {
        return ESP_FAIL;
    }

    if (jpeg_size > MAX_FRAME_SIZE) {
        ESP_LOGW(TAG, "Frame too large: %zu bytes", jpeg_size);
        return ESP_FAIL;
    }

    // Rate limiting
    uint32_t now = xTaskGetTickCount() * portTICK_PERIOD_MS;
    if (last_frame_sent_time > 0 && (now - last_frame_sent_time) < FRAME_INTERVAL_MS) {
        return ESP_FAIL;  // Drop frame
    }

    CameraFrame frame;
    frame.frame_id = frame_id;
    frame.timestamp = now;
    frame.size = jpeg_size;

    // Allocate and copy frame data
    frame.data = (uint8_t*)malloc(jpeg_size);
    if (frame.data == nullptr) {
        ESP_LOGE(TAG, "Failed to allocate frame buffer");
        return ESP_FAIL;
    }
    memcpy(frame.data, jpeg_data, jpeg_size);

    // Try to queue (don't block)
    if (xQueueSend(camera_queue, &frame, 0) != pdTRUE) {
        ESP_LOGW(TAG, "Camera queue full, dropping frame");
        free(frame.data);
        stats.camera_queue_overflows++;
        return ESP_FAIL;
    }

    last_frame_sent_time = now;
    return ESP_OK;
}

esp_err_t queue_audio_chunk(const uint8_t* audio_data, size_t audio_size, uint32_t sequence) {
    if (audio_queue == nullptr || !audio_streaming_active) {
        return ESP_FAIL;
    }

    if (audio_size > MAX_AUDIO_CHUNK_SIZE) {
        ESP_LOGW(TAG, "Audio chunk too large: %zu bytes", audio_size);
        return ESP_FAIL;
    }

    AudioChunk chunk;
    chunk.sequence = sequence;
    chunk.timestamp = xTaskGetTickCount() * portTICK_PERIOD_MS;
    chunk.size = audio_size;

    // Allocate and copy audio data
    chunk.data = (uint8_t*)malloc(audio_size);
    if (chunk.data == nullptr) {
        ESP_LOGE(TAG, "Failed to allocate audio buffer");
        return ESP_FAIL;
    }
    memcpy(chunk.data, audio_data, audio_size);

    // Try to queue (don't block)
    if (xQueueSend(audio_queue, &chunk, 0) != pdTRUE) {
        ESP_LOGW(TAG, "Audio queue full, dropping chunk");
        free(chunk.data);
        stats.audio_queue_overflows++;
        return ESP_FAIL;
    }

    return ESP_OK;
}

StreamStats get_stats() {
    return stats;
}

void cleanup() {
    stop_camera_streaming();
    stop_audio_streaming();

    if (camera_task_handle != nullptr) {
        vTaskDelete(camera_task_handle);
        camera_task_handle = nullptr;
    }

    if (audio_task_handle != nullptr) {
        vTaskDelete(audio_task_handle);
        audio_task_handle = nullptr;
    }

    if (camera_queue != nullptr) {
        vQueueDelete(camera_queue);
        camera_queue = nullptr;
    }

    if (audio_queue != nullptr) {
        vQueueDelete(audio_queue);
        audio_queue = nullptr;
    }

    // Cleanup persistent HTTP clients
    if (persistent_camera_client != nullptr) {
        esp_http_client_cleanup(persistent_camera_client);
        persistent_camera_client = nullptr;
    }

    if (persistent_audio_client != nullptr) {
        esp_http_client_cleanup(persistent_audio_client);
        persistent_audio_client = nullptr;
    }

    ESP_LOGI(TAG, "Backend streaming cleaned up");
}

} // namespace backend_stream
